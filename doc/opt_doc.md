# 怎么产生优化图

基于静态图的骨架枚举

基于静态策略和惰性动态执行的参数枚举

为什么参数需要边执行边设定？为了加速搜索。因为很多优化节点的参数需要依赖于之前所有的优化产生的新矩阵的非零元分布，即相比骨架的静态枚举，良好的参数枚举需要更多的矩阵非零元分布的细粒度信息，这需要预执行才能知道。所以根据之前优化的累计结果和参数设定策略来执行参数的枚举比完全将优化过程视为黑盒不利于给出良好的枚举参数，从而需要更多的搜索过程。

在模板层次触发对应的压缩子图的优化是最好的，因为到底要怎么优化和要采用的模板相关。模板对子图执行优化，并且重新执行子图。和优化相关的节点不能修改稠密图，因为这会影响到其他子图。

# 大概率被利用的模板

DIRECT_ATOM_TEMPLATE_WARP_COMPRESS、DIRECT_ATOM_TEMPLATE_WARP_BLOCK_COMPRESS、SHARED_MEMORY_TEMPLATE_WARP_COMPRESS、SHARED_MEMORY_LONG_ROW_TEMPLATE、SHARED_MEMORY_TOTAL_WARP_REDUCE_TEMPLATE、DIRECT_ATOM_TOTAL_WARP_REDUCE_TEMPLATE、UNALIGNED_WARP_REDUCE_SAME_TLB_SIZE_TEMPLATE、UNALIGNED_WARP_REDUCE_SAME_TLB_SIZE_TEMPLATE_WITH_WARP_REDUCE。

其中，对于row padding优化比较敏感的是DIRECT_ATOM_TEMPLATE_WRAP_COMPRESS、DIRECT_ATOM_TEMPLATE_WARP_BLOCK_COMPRESS。可以设计一个rule加以辨认。对于DIRECT_ATOM_TEMPLATE_WRAP_BLOCK_COMPRESS来说，当thread是行切分的时候，代表这里出现了ELL格式，行数量要自动padding到32的倍数，来使得一些索引的压缩可以执行，并且让性能最大化。对于DIRECT_ATOM_TEMPLATE_WRAP_COMPRESS来说，一般来说用到这个模板说明BLB是行切分的，如果线程也是行切分的（或者更宽泛点如果每一行的TLB的数量是一致的），BLB的行切分执行之前，加一个row padding，将压缩子图行数量设定为BLB行数量的整数倍。

# 用图枚举+用户定义的枚举策略代替图优化

现在主要的图优化体现在row_padding上，所以如果可以用图枚举来处理图优化的问题。加入一个用户定义节点依赖，当没有row padding的时候，就不允许在之后加入DIRECT_ATOM_TEMPLATE_WRAP_COMPRESS和DIRECT_ATOM_TEMPLATE_WRAP_BLOCK_COMPRESS这两种类型的模板。